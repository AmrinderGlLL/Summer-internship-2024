{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:05.852905Z",
     "iopub.status.busy": "2024-05-20T07:05:05.852220Z",
     "iopub.status.idle": "2024-05-20T07:05:11.970808Z",
     "shell.execute_reply": "2024-05-20T07:05:11.970233Z",
     "shell.execute_reply.started": "2024-05-20T05:15:09.086514Z"
    },
    "papermill": {
     "duration": 6.147472,
     "end_time": "2024-05-20T07:05:11.970946",
     "exception": false,
     "start_time": "2024-05-20T07:05:05.823474",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.7/site-packages/tensorflow_addons/utils/ensure_tf_install.py:68: UserWarning: Tensorflow Addons supports using Python ops for all Tensorflow versions above or equal to 2.2.0 and strictly below 2.3.0 (nightly versions are not supported). \n",
      " The versions of TensorFlow you are currently using is 2.3.0 and is not supported. \n",
      "Some things might work, some things might not.\n",
      "If you were to encounter a bug, do not file an issue.\n",
      "If you want to make sure you're using a tested and supported configuration, either change the TensorFlow version or the TensorFlow Addons's version. \n",
      "You can find the compatibility matrix in TensorFlow Addon's readme:\n",
      "https://github.com/tensorflow/addons\n",
      "  UserWarning,\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import json\n",
    "\n",
    "import cv2\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import pydicom\n",
    "\n",
    "from keras import layers\n",
    "from keras.applications import DenseNet121, ResNet50V2, InceptionV3\n",
    "from keras.preprocessing.image import ImageDataGenerator\n",
    "from keras.callbacks import Callback, ModelCheckpoint, ReduceLROnPlateau, EarlyStopping\n",
    "from keras.preprocessing.image import ImageDataGenerator\n",
    "from keras.initializers import Constant\n",
    "from keras.utils import Sequence\n",
    "from keras.models import Sequential\n",
    "from keras.optimizers import Adam\n",
    "from keras.models import Model, load_model\n",
    "from keras.layers import GlobalAveragePooling2D, Dense, Activation, concatenate, Dropout\n",
    "from keras.initializers import glorot_normal, he_normal\n",
    "from keras.regularizers import l2\n",
    "\n",
    "import keras.metrics as M\n",
    "import tensorflow_addons as tfa\n",
    "import pickle\n",
    "\n",
    "from keras import backend as K\n",
    "\n",
    "import tensorflow as tf\n",
    "from tensorflow.python.ops import array_ops\n",
    "\n",
    "from tqdm import tqdm\n",
    "from sklearn.model_selection import train_test_split, StratifiedKFold\n",
    "\n",
    "import cupy as cp\n",
    "\n",
    "import warnings\n",
    "warnings.filterwarnings(action='once')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "papermill": {
     "duration": 0.016638,
     "end_time": "2024-05-20T07:05:12.005419",
     "exception": false,
     "start_time": "2024-05-20T07:05:11.988781",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "_cell_guid": "79c7e3d0-c299-4dcb-8224-4455121ee9b0",
    "_uuid": "d629ff2d2480ee46fbb7e2d37f6b5fab8052498a",
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:12.043212Z",
     "iopub.status.busy": "2024-05-20T07:05:12.042387Z",
     "iopub.status.idle": "2024-05-20T07:05:12.044978Z",
     "shell.execute_reply": "2024-05-20T07:05:12.044389Z",
     "shell.execute_reply.started": "2024-05-20T05:15:09.100268Z"
    },
    "papermill": {
     "duration": 0.02315,
     "end_time": "2024-05-20T07:05:12.045075",
     "exception": false,
     "start_time": "2024-05-20T07:05:12.021925",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "BASE_PATH = '../input/rsna-intracranial-hemorrhage-detection/rsna-intracranial-hemorrhage-detection/'\n",
    "TRAIN_DIR = 'stage_2_train/'\n",
    "TEST_DIR = 'stage_2_test/'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:12.091413Z",
     "iopub.status.busy": "2024-05-20T07:05:12.090786Z",
     "iopub.status.idle": "2024-05-20T07:05:22.722213Z",
     "shell.execute_reply": "2024-05-20T07:05:22.722755Z",
     "shell.execute_reply.started": "2024-05-20T05:15:09.114979Z"
    },
    "papermill": {
     "duration": 10.661259,
     "end_time": "2024-05-20T07:05:22.722914",
     "exception": false,
     "start_time": "2024-05-20T07:05:12.061655",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>ID</th>\n",
       "      <th>Label</th>\n",
       "      <th>id</th>\n",
       "      <th>subtype</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>ID_12cadc6af_epidural</td>\n",
       "      <td>0</td>\n",
       "      <td>ID_12cadc6af</td>\n",
       "      <td>epidural</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>ID_12cadc6af_intraparenchymal</td>\n",
       "      <td>0</td>\n",
       "      <td>ID_12cadc6af</td>\n",
       "      <td>intraparenchymal</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>ID_12cadc6af_intraventricular</td>\n",
       "      <td>0</td>\n",
       "      <td>ID_12cadc6af</td>\n",
       "      <td>intraventricular</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>ID_12cadc6af_subarachnoid</td>\n",
       "      <td>0</td>\n",
       "      <td>ID_12cadc6af</td>\n",
       "      <td>subarachnoid</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>ID_12cadc6af_subdural</td>\n",
       "      <td>0</td>\n",
       "      <td>ID_12cadc6af</td>\n",
       "      <td>subdural</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                              ID  Label            id           subtype\n",
       "0          ID_12cadc6af_epidural      0  ID_12cadc6af          epidural\n",
       "1  ID_12cadc6af_intraparenchymal      0  ID_12cadc6af  intraparenchymal\n",
       "2  ID_12cadc6af_intraventricular      0  ID_12cadc6af  intraventricular\n",
       "3      ID_12cadc6af_subarachnoid      0  ID_12cadc6af      subarachnoid\n",
       "4          ID_12cadc6af_subdural      0  ID_12cadc6af          subdural"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_df = pd.read_csv(BASE_PATH + 'stage_2_train.csv')\n",
    "train_df['id'] = train_df['ID'].apply(lambda st: \"ID_\" + st.split('_')[1])\n",
    "train_df['subtype'] = train_df['ID'].apply(lambda st: st.split('_')[2])\n",
    "train_df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:23.222262Z",
     "iopub.status.busy": "2024-05-20T07:05:22.994637Z",
     "iopub.status.idle": "2024-05-20T07:05:23.562513Z",
     "shell.execute_reply": "2024-05-20T07:05:23.561866Z",
     "shell.execute_reply.started": "2024-05-20T05:15:19.524671Z"
    },
    "papermill": {
     "duration": 0.822135,
     "end_time": "2024-05-20T07:05:23.562624",
     "exception": false,
     "start_time": "2024-05-20T07:05:22.740489",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>id</th>\n",
       "      <th>subtype</th>\n",
       "      <th>Label</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>ID_12cadc6af</td>\n",
       "      <td>epidural</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>ID_12cadc6af</td>\n",
       "      <td>intraparenchymal</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>ID_12cadc6af</td>\n",
       "      <td>intraventricular</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>ID_12cadc6af</td>\n",
       "      <td>subarachnoid</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>ID_12cadc6af</td>\n",
       "      <td>subdural</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "             id           subtype  Label\n",
       "0  ID_12cadc6af          epidural      0\n",
       "1  ID_12cadc6af  intraparenchymal      0\n",
       "2  ID_12cadc6af  intraventricular      0\n",
       "3  ID_12cadc6af      subarachnoid      0\n",
       "4  ID_12cadc6af          subdural      0"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_df = train_df[[\"id\",\"subtype\",\"Label\"]]\n",
    "train_df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:23.626758Z",
     "iopub.status.busy": "2024-05-20T07:05:23.625736Z",
     "iopub.status.idle": "2024-05-20T07:05:31.155695Z",
     "shell.execute_reply": "2024-05-20T07:05:31.155010Z",
     "shell.execute_reply.started": "2024-05-20T05:15:20.324251Z"
    },
    "papermill": {
     "duration": 7.57412,
     "end_time": "2024-05-20T07:05:31.155808",
     "exception": false,
     "start_time": "2024-05-20T07:05:23.581688",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th>subtype</th>\n",
       "      <th>any</th>\n",
       "      <th>epidural</th>\n",
       "      <th>intraparenchymal</th>\n",
       "      <th>intraventricular</th>\n",
       "      <th>subarachnoid</th>\n",
       "      <th>subdural</th>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>id</th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>ID_000012eaf</th>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>ID_000039fa0</th>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>ID_00005679d</th>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>ID_00008ce3c</th>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>ID_0000950d7</th>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "subtype       any  epidural  intraparenchymal  intraventricular  subarachnoid  \\\n",
       "id                                                                              \n",
       "ID_000012eaf    0         0                 0                 0             0   \n",
       "ID_000039fa0    0         0                 0                 0             0   \n",
       "ID_00005679d    0         0                 0                 0             0   \n",
       "ID_00008ce3c    0         0                 0                 0             0   \n",
       "ID_0000950d7    0         0                 0                 0             0   \n",
       "\n",
       "subtype       subdural  \n",
       "id                      \n",
       "ID_000012eaf         0  \n",
       "ID_000039fa0         0  \n",
       "ID_00005679d         0  \n",
       "ID_00008ce3c         0  \n",
       "ID_0000950d7         0  "
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_df = pd.pivot_table(train_df,index=\"id\",columns=\"subtype\",values=\"Label\")\n",
    "train_df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:31.196570Z",
     "iopub.status.busy": "2024-05-20T07:05:31.195831Z",
     "iopub.status.idle": "2024-05-20T07:05:31.917563Z",
     "shell.execute_reply": "2024-05-20T07:05:31.916976Z",
     "shell.execute_reply.started": "2024-05-20T05:15:27.880467Z"
    },
    "papermill": {
     "duration": 0.743635,
     "end_time": "2024-05-20T07:05:31.917679",
     "exception": false,
     "start_time": "2024-05-20T07:05:31.174044",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "pivot_df = train_df.copy()\n",
    "pivot_df.drop(\"ID_6431af929\",inplace=True)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:31.984799Z",
     "iopub.status.busy": "2024-05-20T07:05:31.978685Z",
     "iopub.status.idle": "2024-05-20T07:05:31.987519Z",
     "shell.execute_reply": "2024-05-20T07:05:31.987020Z",
     "shell.execute_reply.started": "2024-05-20T05:15:28.555615Z"
    },
    "papermill": {
     "duration": 0.050687,
     "end_time": "2024-05-20T07:05:31.987627",
     "exception": false,
     "start_time": "2024-05-20T07:05:31.936940",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def map_to_gradient(grey_img):\n",
    "    rainbow_img = np.zeros((grey_img.shape[0], grey_img.shape[1], 3))\n",
    "    rainbow_img[:, :, 0] = np.clip(4 * grey_img - 2, 0, 1.0) * (grey_img > 0) * (grey_img <= 1.0)\n",
    "    rainbow_img[:, :, 1] =  np.clip(4 * grey_img * (grey_img <=0.75), 0,1) + np.clip((-4*grey_img + 4) * (grey_img > 0.75), 0, 1)\n",
    "    rainbow_img[:, :, 2] = np.clip(-4 * grey_img + 2, 0, 1.0) * (grey_img > 0) * (grey_img <= 1.0)\n",
    "    return rainbow_img\n",
    "\n",
    "def rainbow_window(dcm):\n",
    "    grey_img = window_image(dcm, 40, 80)\n",
    "    return map_to_gradient(grey_img)\n",
    "\n",
    "#import cupy as cp\n",
    "\n",
    "def sigmoid_window(dcm, window_center, window_width, U=1.0, eps=(1.0 / 255.0)):\n",
    "    img = dcm.pixel_array\n",
    "    img = cp.array(np.array(img))\n",
    "    _, _, intercept, slope = get_windowing(dcm)\n",
    "    img = img * slope + intercept\n",
    "    ue = cp.log((U / eps) - 1.0)\n",
    "    W = (2 / window_width) * ue\n",
    "    b = ((-2 * window_center) / window_width) * ue\n",
    "    z = W * img + b\n",
    "    img = U / (1 + cp.power(np.e, -1.0 * z))\n",
    "    img = (img - cp.min(img)) / (cp.max(img) - cp.min(img))\n",
    "    return cp.asnumpy(img)\n",
    "\n",
    "def sigmoid_bsb_window(dcm):\n",
    "    brain_img = sigmoid_window(dcm, 40, 80)\n",
    "    subdural_img = sigmoid_window(dcm, 80, 200)\n",
    "    bone_img = sigmoid_window(dcm, 600, 2000)\n",
    "    \n",
    "    bsb_img = np.zeros((brain_img.shape[0], brain_img.shape[1], 3))\n",
    "    bsb_img[:, :, 0] = brain_img\n",
    "    bsb_img[:, :, 1] = subdural_img\n",
    "    bsb_img[:, :, 2] = bone_img\n",
    "    return bsb_img\n",
    "\n",
    "def window_image(dcm, window_center, window_width):\n",
    "    _, _, intercept, slope = get_windowing(dcm)\n",
    "    img = dcm.pixel_array * slope + intercept\n",
    "    img_min = window_center - window_width // 2\n",
    "    img_max = window_center + window_width // 2\n",
    "    img[img < img_min] = img_min\n",
    "    img[img > img_max] = img_max\n",
    "    img = (img - np.min(img)) / (np.max(img) - np.min(img))\n",
    "    return img\n",
    "\n",
    "def bsb_window(dcm):\n",
    "    brain_img = window_image(dcm, 40, 80)\n",
    "    subdural_img = window_image(dcm, 80, 200)\n",
    "    bone_img = window_image(dcm, 600, 2000)\n",
    "    \n",
    "    bsb_img = np.zeros((brain_img.shape[0], brain_img.shape[1], 3))\n",
    "    bsb_img[:, :, 0] = brain_img\n",
    "    bsb_img[:, :, 1] = subdural_img\n",
    "    bsb_img[:, :, 2] = bone_img\n",
    "    return bsb_img\n",
    "    \n",
    "def get_first_of_dicom_field_as_int(x):\n",
    "    #get x[0] as in int is x is a 'pydicom.multival.MultiValue', otherwise get int(x)\n",
    "    if type(x) == pydicom.multival.MultiValue:\n",
    "        return int(x[0])\n",
    "    else:\n",
    "        return int(x)\n",
    "\n",
    "def get_windowing(data):\n",
    "    dicom_fields = [data[('0028','1050')].value, #window center\n",
    "                    data[('0028','1051')].value, #window width\n",
    "                    data[('0028','1052')].value, #intercept\n",
    "                    data[('0028','1053')].value] #slope\n",
    "    return [get_first_of_dicom_field_as_int(x) for x in dicom_fields]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:32.056722Z",
     "iopub.status.busy": "2024-05-20T07:05:32.055940Z",
     "iopub.status.idle": "2024-05-20T07:05:32.058709Z",
     "shell.execute_reply": "2024-05-20T07:05:32.058082Z",
     "shell.execute_reply.started": "2024-05-20T05:15:28.586749Z"
    },
    "papermill": {
     "duration": 0.0525,
     "end_time": "2024-05-20T07:05:32.058833",
     "exception": false,
     "start_time": "2024-05-20T07:05:32.006333",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def preprocess(file,type=\"WINDOW\",fdir=TRAIN_DIR):\n",
    "    dcm = pydicom.dcmread(BASE_PATH+fdir+file+\".dcm\")\n",
    "    if type == \"WINDOW\":\n",
    "        window_center , window_width, intercept, slope = get_windowing(dcm)\n",
    "        w = window_image(dcm, window_center, window_width)\n",
    "        win_img = np.repeat(w[:, :, np.newaxis], 3, axis=2)\n",
    "        #return win_img\n",
    "    elif type == \"SIGMOID\":\n",
    "        window_center , window_width, intercept, slope = get_windowing(dcm)\n",
    "        test_img = dcm.pixel_array\n",
    "        w = sigmoid_window(dcm, window_center, window_width)\n",
    "        win_img = np.repeat(w[:, :, np.newaxis], 3, axis=2)\n",
    "        #return win_img\n",
    "    elif type == \"BSB\":\n",
    "        win_img = bsb_window(dcm)\n",
    "        #return win_img\n",
    "    elif type == \"SIGMOID_BSB\":\n",
    "        win_img = sigmoid_bsb_window(dcm)\n",
    "    elif type == \"GRADIENT\":\n",
    "        win_img = rainbow_window(dcm)\n",
    "        #return win_img\n",
    "    else:\n",
    "        win_img = dcm.pixel_array\n",
    "    resized = cv2.resize(win_img,(224,224))\n",
    "    return resized\n",
    "\n",
    "class DataLoader(Sequence):\n",
    "    def __init__(self, dataframe,\n",
    "                 batch_size,\n",
    "                 shuffle,\n",
    "                 input_shape,\n",
    "                 num_classes=6,\n",
    "                 steps=None,\n",
    "                 prep=\"BSB\",\n",
    "                 fdir=TRAIN_DIR):\n",
    "        \n",
    "        self.data_ids = dataframe.index.values\n",
    "        self.dataframe = dataframe\n",
    "        self.batch_size = batch_size\n",
    "        self.shuffle = shuffle\n",
    "        self.input_shape = input_shape\n",
    "        self.num_classes = num_classes\n",
    "        self.current_epoch=0\n",
    "        self.prep = prep\n",
    "        self.fdir = fdir\n",
    "        self.steps=steps\n",
    "        if self.steps is not None:\n",
    "            self.steps = np.round(self.steps/3) * 3\n",
    "            self.undersample()\n",
    "        \n",
    "    def undersample(self):\n",
    "        part = np.int(self.steps/3 * self.batch_size)\n",
    "        zero_ids = np.random.choice(self.dataframe.loc[self.dataframe[\"any\"] == 0].index.values, size=5000, replace=False)\n",
    "        hot_ids = np.random.choice(self.dataframe.loc[self.dataframe[\"any\"] == 1].index.values, size=5000, replace=True)\n",
    "        self.data_ids = list(set(zero_ids).union(hot_ids))\n",
    "        np.random.shuffle(self.data_ids)\n",
    "        \n",
    "    # defines the number of steps per epoch\n",
    "    def __len__(self):\n",
    "        if self.steps is None:\n",
    "            return np.int(np.ceil(len(self.data_ids) / np.float(self.batch_size)))\n",
    "        else:\n",
    "            return 3*np.int(self.steps/3) \n",
    "    \n",
    "    # at the end of an epoch: \n",
    "    def on_epoch_end(self):\n",
    "        # if steps is None and shuffle is true:\n",
    "        if self.steps is None:\n",
    "            self.data_ids = self.dataframe.index.values\n",
    "            if self.shuffle:\n",
    "                np.random.shuffle(self.data_ids)\n",
    "        else:\n",
    "            self.undersample()\n",
    "        self.current_epoch += 1\n",
    "    \n",
    "    # should return a batch of images\n",
    "    def __getitem__(self, item):\n",
    "        # select the ids of the current batch\n",
    "        current_ids = self.data_ids[item*self.batch_size:(item+1)*self.batch_size]\n",
    "        X, y = self.__generate_batch(current_ids)\n",
    "        return X, y\n",
    "    \n",
    "    # collect the preprocessed images and targets of one batch\n",
    "    def __generate_batch(self, current_ids):\n",
    "        X = np.empty((self.batch_size, *self.input_shape, 3))\n",
    "        y = np.empty((self.batch_size, self.num_classes))\n",
    "        for idx, ident in enumerate(current_ids):\n",
    "            # Store sample\n",
    "            #image = self.preprocessor.preprocess(ident) \n",
    "            image = preprocess(ident,self.prep,self.fdir)\n",
    "            X[idx] = image\n",
    "            # Store class\n",
    "            y[idx] = self.__get_target(ident)\n",
    "        return X, y\n",
    "    \n",
    "    # extract the targets of one image id:\n",
    "    def __get_target(self, ident):\n",
    "        targets = self.dataframe.loc[ident].values\n",
    "        return targets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:32.106755Z",
     "iopub.status.busy": "2024-05-20T07:05:32.106101Z",
     "iopub.status.idle": "2024-05-20T07:05:32.109056Z",
     "shell.execute_reply": "2024-05-20T07:05:32.108421Z",
     "shell.execute_reply.started": "2024-05-20T05:15:28.618979Z"
    },
    "papermill": {
     "duration": 0.031682,
     "end_time": "2024-05-20T07:05:32.109172",
     "exception": false,
     "start_time": "2024-05-20T07:05:32.077490",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def DenseNet():\n",
    "    densenet = DenseNet121(\n",
    "    #weights='../input/densenet-keras/DenseNet-BC-121-32-no-top.h5',\n",
    "    weights='imagenet',\n",
    "    include_top=False)\n",
    "    return densenet\n",
    "def ResNet():\n",
    "    resnet = ResNet50V2(weights=\"imagenet\",include_top=False)\n",
    "    return resnet\n",
    "def Inception():\n",
    "    incept = InceptionV3(weights=\"imagenet\",include_top=False)\n",
    "    return incept\n",
    "\n",
    "def get_backbone(name):\n",
    "    if name == \"RESNET\":\n",
    "        return ResNet\n",
    "    elif name == \"DENSE\":\n",
    "        return DenseNet\n",
    "    elif name == \"INCEPT\":\n",
    "        return Inception\n",
    "\n",
    "def build_model(backbone):\n",
    "    m = backbone()\n",
    "    x = m.output\n",
    "    x = GlobalAveragePooling2D()(x)\n",
    "    x = Dropout(0.3)(x)\n",
    "    x = Dense(100, activation=\"relu\")(x)\n",
    "    x = Dropout(0.3)(x)\n",
    "    pred = Dense(6,activation=\"sigmoid\")(x)\n",
    "    model = Model(inputs=m.input,outputs=pred)\n",
    "    return model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:32.153490Z",
     "iopub.status.busy": "2024-05-20T07:05:32.152889Z",
     "iopub.status.idle": "2024-05-20T07:05:32.435878Z",
     "shell.execute_reply": "2024-05-20T07:05:32.435115Z",
     "shell.execute_reply.started": "2024-05-20T05:15:28.632619Z"
    },
    "papermill": {
     "duration": 0.308264,
     "end_time": "2024-05-20T07:05:32.436005",
     "exception": false,
     "start_time": "2024-05-20T07:05:32.127741",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(481792, 6)\n",
      "(120449, 6)\n"
     ]
    }
   ],
   "source": [
    "train,test = train_test_split(pivot_df,test_size=0.2,random_state=42,shuffle=True)\n",
    "\n",
    "split_seed = 1\n",
    "kfold = StratifiedKFold(n_splits=5, random_state=split_seed,shuffle=True).split(np.arange(train.shape[0]), train[\"any\"].values)\n",
    "\n",
    "train_idx, dev_idx = next(kfold)\n",
    "\n",
    "train_data = train.iloc[train_idx]\n",
    "dev_data = train.iloc[dev_idx]\n",
    "\n",
    "print(train_data.shape)\n",
    "print(dev_data.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:05:32.491759Z",
     "iopub.status.busy": "2024-05-20T07:05:32.490842Z",
     "iopub.status.idle": "2024-05-20T07:51:37.789090Z",
     "shell.execute_reply": "2024-05-20T07:51:37.788334Z",
     "shell.execute_reply.started": "2024-05-20T05:15:28.930249Z"
    },
    "papermill": {
     "duration": 2765.334783,
     "end_time": "2024-05-20T07:51:37.789388",
     "exception": false,
     "start_time": "2024-05-20T07:05:32.454605",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Downloading data from https://storage.googleapis.com/tensorflow/keras-applications/resnet/resnet50v2_weights_tf_dim_ordering_tf_kernels_notop.h5\n",
      "94674944/94668760 [==============================] - 5s 0us/step\n",
      "Epoch 1/10\n",
      "501/501 [==============================] - ETA: 0s - loss: 0.7165 - categorical_accuracy: 0.3258\n",
      "Epoch 00001: val_loss improved from inf to 0.79876, saving model to ./RESNET_SIGMOID_500_10.model\n",
      "501/501 [==============================] - 286s 571ms/step - loss: 0.7165 - categorical_accuracy: 0.3258 - val_loss: 0.7988 - val_categorical_accuracy: 0.4889\n",
      "Epoch 2/10\n",
      "501/501 [==============================] - ETA: 0s - loss: 0.6961 - categorical_accuracy: 0.3611\n",
      "Epoch 00002: val_loss did not improve from 0.79876\n",
      "501/501 [==============================] - 260s 518ms/step - loss: 0.6961 - categorical_accuracy: 0.3611 - val_loss: 0.8483 - val_categorical_accuracy: 0.5424\n",
      "Epoch 3/10\n",
      "501/501 [==============================] - ETA: 0s - loss: 0.6943 - categorical_accuracy: 0.3578\n",
      "Epoch 00003: val_loss improved from 0.79876 to 0.71190, saving model to ./RESNET_SIGMOID_500_10.model\n",
      "501/501 [==============================] - 284s 566ms/step - loss: 0.6943 - categorical_accuracy: 0.3578 - val_loss: 0.7119 - val_categorical_accuracy: 0.0257\n",
      "Epoch 4/10\n",
      "501/501 [==============================] - ETA: 0s - loss: 0.6976 - categorical_accuracy: 0.2769\n",
      "Epoch 00004: val_loss did not improve from 0.71190\n",
      "501/501 [==============================] - 259s 516ms/step - loss: 0.6976 - categorical_accuracy: 0.2769 - val_loss: 0.7617 - val_categorical_accuracy: 0.6612\n",
      "Epoch 5/10\n",
      "501/501 [==============================] - ETA: 0s - loss: 0.6984 - categorical_accuracy: 0.2470\n",
      "Epoch 00005: val_loss improved from 0.71190 to 0.70498, saving model to ./RESNET_SIGMOID_500_10.model\n",
      "501/501 [==============================] - 290s 578ms/step - loss: 0.6984 - categorical_accuracy: 0.2470 - val_loss: 0.7050 - val_categorical_accuracy: 0.9734\n",
      "Epoch 6/10\n",
      "501/501 [==============================] - ETA: 0s - loss: 0.6941 - categorical_accuracy: 0.2667\n",
      "Epoch 00006: val_loss did not improve from 0.70498\n",
      "501/501 [==============================] - 261s 520ms/step - loss: 0.6941 - categorical_accuracy: 0.2667 - val_loss: 0.7074 - val_categorical_accuracy: 0.8428\n",
      "Epoch 7/10\n",
      "501/501 [==============================] - ETA: 0s - loss: 0.6946 - categorical_accuracy: 0.2845\n",
      "Epoch 00007: val_loss improved from 0.70498 to 0.70347, saving model to ./RESNET_SIGMOID_500_10.model\n",
      "501/501 [==============================] - 294s 586ms/step - loss: 0.6946 - categorical_accuracy: 0.2845 - val_loss: 0.7035 - val_categorical_accuracy: 0.6385\n",
      "Epoch 8/10\n",
      "501/501 [==============================] - ETA: 0s - loss: 0.6970 - categorical_accuracy: 0.3414\n",
      "Epoch 00008: val_loss did not improve from 0.70347\n",
      "501/501 [==============================] - 261s 522ms/step - loss: 0.6970 - categorical_accuracy: 0.3414 - val_loss: 0.7079 - val_categorical_accuracy: 0.6876\n",
      "Epoch 9/10\n",
      "501/501 [==============================] - ETA: 0s - loss: 0.6976 - categorical_accuracy: 0.3288\n",
      "Epoch 00009: val_loss did not improve from 0.70347\n",
      "501/501 [==============================] - 261s 522ms/step - loss: 0.6976 - categorical_accuracy: 0.3288 - val_loss: 0.7149 - val_categorical_accuracy: 0.6613\n",
      "Epoch 10/10\n",
      "501/501 [==============================] - ETA: 0s - loss: 0.6942 - categorical_accuracy: 0.3249\n",
      "Epoch 00010: val_loss did not improve from 0.70347\n",
      "501/501 [==============================] - 262s 523ms/step - loss: 0.6942 - categorical_accuracy: 0.3249 - val_loss: 0.7060 - val_categorical_accuracy: 0.8701\n",
      "Generating predictions\n"
     ]
    }
   ],
   "source": [
    "f1 = tfa.losses.SigmoidFocalCrossEntropy(from_logits=True)\n",
    "def casting_focal_loss():\n",
    "    def inner_casting(y_true,y_pred):\n",
    "        y_true = tf.cast(y_true, tf.float32)\n",
    "        y_true = tf.clip_by_value(y_true,1e-7,1-1e-7)\n",
    "        y_pred = tf.cast(y_pred, tf.float32)\n",
    "        y_pred = tf.clip_by_value(y_pred,1e-7,1-1e-7)\n",
    "        \n",
    "        return f1(y_true,y_pred)\n",
    "    return inner_casting\n",
    "METRICS = ['categorical_accuracy']\n",
    "\n",
    "#LOSS = tfa.losses.SigmoidFocalCrossEntropy(from_logits=False)\n",
    "LOSS = casting_focal_loss()\n",
    "\n",
    "BATCH_SIZE = 32\n",
    "TRAIN_STEPS = 500#train_data.shape[0] // BATCH_SIZE\n",
    "VAL_STEPS = 500#dev_data.shape[0] // BATCH_SIZE\n",
    "EPOCHS = 10\n",
    "#WEIGHT = [2.0,1.0,1.0,1.0,1.0,1.0]\n",
    "ALPHA = 0.5\n",
    "GAMMA = 2\n",
    "\n",
    "LR = 0.0001\n",
    "\n",
    "PREP = \"SIGMOID\"\n",
    "ARCH = 'RESNET'\n",
    "\n",
    "train_dataloader = DataLoader(train_data,\n",
    "                              BATCH_SIZE,\n",
    "                              shuffle=True,\n",
    "                              input_shape=(224,224),\n",
    "                              steps=TRAIN_STEPS,\n",
    "                              prep=PREP)\n",
    "\n",
    "dev_dataloader = DataLoader(dev_data, \n",
    "                            BATCH_SIZE,\n",
    "                            shuffle=True,\n",
    "                            input_shape=(224,224),\n",
    "                            steps=VAL_STEPS,\n",
    "                            prep=PREP)\n",
    "test_dataloader = DataLoader(test,\n",
    "                            BATCH_SIZE,\n",
    "                            shuffle=False,\n",
    "                            input_shape=(224,224),\n",
    "                            prep=PREP)\n",
    "\n",
    "cpath = \"./\" + ARCH + \"_\" + PREP + \"_\" + str(TRAIN_STEPS) + \"_\" + str(EPOCHS)\n",
    "checkpoint = ModelCheckpoint(filepath=cpath + \".model\",mode=\"min\",verbose=1,save_best_only=True,save_weights_only=False,period=1)\n",
    "\n",
    "model = build_model(get_backbone(ARCH))\n",
    "\n",
    "model.compile(optimizer=Adam(learning_rate=LR),loss=LOSS,metrics=METRICS)\n",
    "\n",
    "history = model.fit_generator(generator=train_dataloader,validation_data=dev_dataloader,epochs=EPOCHS,workers=8,callbacks=[checkpoint])\n",
    "\n",
    "with open(cpath + \".history\", 'wb') as file_pi:\n",
    "    pickle.dump(history.history, file_pi)\n",
    "    \n",
    "print(\"Generating predictions\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:51:41.597198Z",
     "iopub.status.busy": "2024-05-20T07:51:41.596531Z",
     "iopub.status.idle": "2024-05-20T07:51:42.345222Z",
     "shell.execute_reply": "2024-05-20T07:51:42.344703Z",
     "shell.execute_reply.started": "2024-05-20T06:00:59.657930Z"
    },
    "papermill": {
     "duration": 2.652851,
     "end_time": "2024-05-20T07:51:42.345336",
     "exception": false,
     "start_time": "2024-05-20T07:51:39.692485",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>ID</th>\n",
       "      <th>Label</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>ID_0fbf6a978_epidural</td>\n",
       "      <td>0.5</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>ID_0fbf6a978_intraparenchymal</td>\n",
       "      <td>0.5</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>ID_0fbf6a978_intraventricular</td>\n",
       "      <td>0.5</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>ID_0fbf6a978_subarachnoid</td>\n",
       "      <td>0.5</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>ID_0fbf6a978_subdural</td>\n",
       "      <td>0.5</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                              ID  Label\n",
       "0          ID_0fbf6a978_epidural    0.5\n",
       "1  ID_0fbf6a978_intraparenchymal    0.5\n",
       "2  ID_0fbf6a978_intraventricular    0.5\n",
       "3      ID_0fbf6a978_subarachnoid    0.5\n",
       "4          ID_0fbf6a978_subdural    0.5"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "test_csv = \"../input/rsna-intracranial-hemorrhage-detection/rsna-intracranial-hemorrhage-detection/stage_2_sample_submission.csv\"\n",
    "BASE_PATH = \"../input/rsna-intracranial-hemorrhage-detection/rsna-intracranial-hemorrhage-detection/\"\n",
    "TEST_DIR = \"stage_2_test/\"\n",
    "test_df = pd.read_csv(test_csv)\n",
    "test_df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:51:46.189799Z",
     "iopub.status.busy": "2024-05-20T07:51:46.188728Z",
     "iopub.status.idle": "2024-05-20T07:51:49.138503Z",
     "shell.execute_reply": "2024-05-20T07:51:49.137867Z",
     "shell.execute_reply.started": "2024-05-20T06:01:00.690161Z"
    },
    "papermill": {
     "duration": 4.928223,
     "end_time": "2024-05-20T07:51:49.138614",
     "exception": false,
     "start_time": "2024-05-20T07:51:44.210391",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>id</th>\n",
       "      <th>subtype</th>\n",
       "      <th>label</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>ID_0fbf6a978</td>\n",
       "      <td>epidural</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>ID_0fbf6a978</td>\n",
       "      <td>intraparenchymal</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>ID_0fbf6a978</td>\n",
       "      <td>intraventricular</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>ID_0fbf6a978</td>\n",
       "      <td>subarachnoid</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>ID_0fbf6a978</td>\n",
       "      <td>subdural</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "             id           subtype  label\n",
       "0  ID_0fbf6a978          epidural      0\n",
       "1  ID_0fbf6a978  intraparenchymal      0\n",
       "2  ID_0fbf6a978  intraventricular      0\n",
       "3  ID_0fbf6a978      subarachnoid      0\n",
       "4  ID_0fbf6a978          subdural      0"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "testdf = test_df.ID.str.rsplit(\"_\", n=1, expand=True)\n",
    "testdf = testdf.rename({0: \"id\", 1: \"subtype\"}, axis=1)\n",
    "testdf.loc[:, \"label\"] = 0\n",
    "testdf.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:51:52.977959Z",
     "iopub.status.busy": "2024-05-20T07:51:52.977111Z",
     "iopub.status.idle": "2024-05-20T07:51:53.937986Z",
     "shell.execute_reply": "2024-05-20T07:51:53.937374Z",
     "shell.execute_reply.started": "2024-05-20T06:01:04.167663Z"
    },
    "papermill": {
     "duration": 2.937609,
     "end_time": "2024-05-20T07:51:53.938094",
     "exception": false,
     "start_time": "2024-05-20T07:51:51.000485",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th>subtype</th>\n",
       "      <th>any</th>\n",
       "      <th>epidural</th>\n",
       "      <th>intraparenchymal</th>\n",
       "      <th>intraventricular</th>\n",
       "      <th>subarachnoid</th>\n",
       "      <th>subdural</th>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>id</th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>ID_000000e27</th>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>ID_000009146</th>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>ID_00007b8cb</th>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>ID_000134952</th>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>ID_000176f2a</th>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "subtype       any  epidural  intraparenchymal  intraventricular  subarachnoid  \\\n",
       "id                                                                              \n",
       "ID_000000e27    0         0                 0                 0             0   \n",
       "ID_000009146    0         0                 0                 0             0   \n",
       "ID_00007b8cb    0         0                 0                 0             0   \n",
       "ID_000134952    0         0                 0                 0             0   \n",
       "ID_000176f2a    0         0                 0                 0             0   \n",
       "\n",
       "subtype       subdural  \n",
       "id                      \n",
       "ID_000000e27         0  \n",
       "ID_000009146         0  \n",
       "ID_00007b8cb         0  \n",
       "ID_000134952         0  \n",
       "ID_000176f2a         0  "
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "testdf = pd.pivot_table(testdf, index=\"id\", columns=\"subtype\", values=\"label\")\n",
    "testdf.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:51:57.670928Z",
     "iopub.status.busy": "2024-05-20T07:51:57.670301Z",
     "iopub.status.idle": "2024-05-20T07:51:57.673318Z",
     "shell.execute_reply": "2024-05-20T07:51:57.672691Z",
     "shell.execute_reply.started": "2024-05-20T06:01:05.155343Z"
    },
    "papermill": {
     "duration": 1.869745,
     "end_time": "2024-05-20T07:51:57.673424",
     "exception": false,
     "start_time": "2024-05-20T07:51:55.803679",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def turn_pred_to_dataframe(data_df, pred):\n",
    "    df = pd.DataFrame(pred, columns=data_df.columns, index=data_df.index)\n",
    "    df = df.stack().reset_index()\n",
    "    df.loc[:, \"ID\"] = df.id.str.cat(df.subtype, sep=\"_\")\n",
    "    df = df.drop([\"id\", \"subtype\"], axis=1)\n",
    "    df = df.rename({0: \"Label\"}, axis=1)\n",
    "    return df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:52:01.451981Z",
     "iopub.status.busy": "2024-05-20T07:52:01.451176Z",
     "iopub.status.idle": "2024-05-20T07:52:01.454031Z",
     "shell.execute_reply": "2024-05-20T07:52:01.453394Z",
     "shell.execute_reply.started": "2024-05-20T06:01:05.163935Z"
    },
    "papermill": {
     "duration": 1.925543,
     "end_time": "2024-05-20T07:52:01.454140",
     "exception": false,
     "start_time": "2024-05-20T07:51:59.528597",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "test_dataloader = DataLoader(testdf,32,shuffle=False,input_shape=(224,224),prep=\"SIGMOID\",fdir=TEST_DIR)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T07:52:05.202184Z",
     "iopub.status.busy": "2024-05-20T07:52:05.201579Z",
     "iopub.status.idle": "2024-05-20T08:39:50.696553Z",
     "shell.execute_reply": "2024-05-20T08:39:50.695957Z",
     "shell.execute_reply.started": "2024-05-20T06:01:05.174931Z"
    },
    "papermill": {
     "duration": 2867.364652,
     "end_time": "2024-05-20T08:39:50.696678",
     "exception": false,
     "start_time": "2024-05-20T07:52:03.332026",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3789/3789 [==============================] - 2863s 756ms/step\n"
     ]
    }
   ],
   "source": [
    "test_pred = model.predict(test_dataloader,verbose=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-20T08:39:57.074498Z",
     "iopub.status.busy": "2024-05-20T08:39:57.073860Z",
     "iopub.status.idle": "2024-05-20T08:40:01.382669Z",
     "shell.execute_reply": "2024-05-20T08:40:01.381980Z",
     "shell.execute_reply.started": "2024-05-20T06:58:19.079185Z"
    },
    "papermill": {
     "duration": 7.509657,
     "end_time": "2024-05-20T08:40:01.382787",
     "exception": false,
     "start_time": "2024-05-20T08:39:53.873130",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "pred = test_pred[0:testdf.shape[0]]\n",
    "pred_df = turn_pred_to_dataframe(testdf,pred)\n",
    "pred_df.to_csv(\"resnet_mfl_pred.csv\",index=False)"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "gpu",
   "dataSources": [
    {
     "databundleVersionId": 1188070,
     "datasetId": 654585,
     "sourceId": 13451,
     "sourceType": "competition"
    }
   ],
   "dockerImageVersionId": 29995,
   "isGpuEnabled": true,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  },
  "papermill": {
   "duration": 5703.180532,
   "end_time": "2024-05-20T08:40:05.190427",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2024-05-20T07:05:02.009895",
   "version": "2.1.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
